

var cls             = require("metaphorjs-class/src/cls.js"),
    MetaphorJs      = require("metaphorjs/src/MetaphorJs.js"),
    extend          = require("metaphorjs/src/func/extend.js"),
    addClass        = require("metaphorjs/src/func/dom/addClass.js"),
    removeClass     = require("metaphorjs/src/func/dom/removeClass.js"),
    isFunction      = require("metaphorjs/src/func/isFunction.js"),
    undf            = require("metaphorjs/src/var/undf.js");

require("../../var/messages.js");
require("../../var/methods.js");
require("../../func/format.js");
require("metaphorjs-observable/src/mixin/Observable.js");

module.exports = (function(){


/* ***************************** GROUP ****************************************** */



    var defaults	= /*group-options-start*/{

        alwaysCheck:		false,			// run tests even the field is proven valid and hasn't changed since last check
        alwaysDisplayState:	false,
        disabled:			false,			// initialize disabled

        value:				null,			// fn(api, vals)
        elem:				null,			// dom node
        errorBox:			null,			// fieldId|dom|jquery|selector|fn(api)
        // fn must return dom|jquery object
        errorField:			null,			// fieldId - relay errors to this field

        data:				null,

        cls: {
            valid: 			'',				// css class for a valid form
            error:			''				// css class for a not valid form
        },

        fields:				[],
        rules:				{},
        messages:			{},

        callback:		{

            scope:			null,

            destroy:		null,
            statechange:	null,
            errorchange:	null,
            displaystate:	null
        }
    }/*group-options-end*/;


    var messages = MetaphorJs.validator.messages,
        methods = MetaphorJs.validator.methods,
        format = MetaphorJs.validator.format;


    return cls({
        $class: "MetaphorJs.validator.Group",
        $mixins: [MetaphorJs.mixin.Observable],

        fields:         null,
        rules:          null,
        cfg:            null,
        vldr:           null,
        enabled:		false,
        invalid:		null,
        valid:			null,
        displayState:	false,
        rulesNum:	    0,
        error:			null,
        data:			null,
        errorBox:		null,
        el:			    null,

        $init: function(options, vldr) {

            options     = options || {};

            var self            = this,
                cfg;

            self._vldr          = vldr;

            self.cfg            = cfg = extend({},
                defaults,
                MetaphorJs.validator.Group.defaults,
                options,
                true, true
            );

            self.data           = options.data;
            self.el             = options.elem;
            self.fields         = {};
            self.rules		    = {};

            cfg.messages        = extend({}, messages, cfg.messages, true, true);

            var i, len;

            if (cfg.rules) {
                self.setRules(cfg.rules, false);
            }

            if (cfg.fields) {
                for (i = 0, len = options.fields.length; i < len; i++) {
                    self.add(vldr.getField(cfg.fields[i]));
                }
            }

            self.enabled = !cfg.disabled;
        },

        /**
         * Enable group
         */
        enable:		function() {
            this.enabled	= true;
            return this;
        },

        /**
         * Disable group
         */
        disable:	function() {
            this.enabled	= false;
            return this;
        },

        /**
         * Is group enabled
         * @return {boolean}
         */
        isEnabled:	function() {
            return this.enabled;
        },

        /**
         * Are all fields in this group valid
         * @return {boolean}
         */
        isValid:		function() {
            var self = this;
            return !self.enabled || (self.invalid === 0 && self.valid === true);
        },

        /**
         * @return {boolean|null}
         */
        getExactValidState: function() {
            return this.valid;
        },

        /**
         * Reset group
         */
        reset:		function() {
            var self = this;
            self.invalid	= 0;
            self.setValidState(null);
            self.setError(null);
            self.doDisplayState();
            return self;
        },

        /**
         * Get user data specified in group config
         */
        getUserData: function() {
            return this.data;
        },

        /**
         * Get group name
         */
        getName: function() {
            return this.cfg.name;
        },

        /**
         * Set group's rules
         * @param {object} list {rule: param}
         * @param {bool} check
         */
        setRules: 	function(list, check) {

            var self = this;

            check = check == undf ? true : check;

            for (var i in list) {
                self.setRule(i, list[i], false);
            }

            if (check) {
                self.check();
            }
            else {
                self.setValidState(null);
            }

            return self;
        },

        /**
         * @param rule
         * @param value
         * @param check
         */
        setRule:	function(rule, value, check) {

            var self = this,
                rules = self.rules;

            check = check == undf ? true : check;

            if (value === null) {
                if (rules[rule]) {
                    self.rulesNum--;
                }
                delete rules[rule];
            }
            else {
                if (!rules[rule]) {
                    self.rulesNum++;
                }
                rules[rule] = value;
                if (self.valid !== null) {
                    self.setValidState(false);
                }
            }

            if (check) {
                self.check();
            }
            else {
                self.setValidState(null);
            }

            return self;
        },

        /**
         * Get group rules
         * @returns {name: value}
         */
        getRules:	function() {
            return extend({}, this.rules);
        },

        /**
         * @returns boolean
         */
        hasRule:	function(name) {
            return this.rules[name] ? true : false;
        },

        /**
         * Set group custom error
         */
        setError:	function(error) {

            var self = this,
                cfg = self.cfg;

            if (self.error != error) {

                if (cfg.errorField) {
                    self.vldr.getField(cfg.errorField).setError(error);
                    self.error = null;
                }
                else {
                    self.error = error;
                    self.trigger('error-change', self, error);
                }
            }
        },

        /**
         * Get current error
         */
        getError: function() {
            return this.error;
        },

        /**
         * @returns {id: field}
         */
        getFields: function() {
            return this.fields;
        },

        enableDisplayState:		function() {
            this.displayState	= true;
            return this;
        },

        disableDisplayState:	function() {
            this.displayState	= false;
            return this;
        },

        check: function() {

            var self    = this,
                cfg     = self.cfg,
                fields  = self.fields,
                rules   = self.rules;

            if (!self.enabled || self.rulesNum == 0) {
                self.setValidState(null);
                self.doDisplayState();
                return true;
            }

            self.countInvalid();

            if (self.invalid > 0) {
                self.setValidState(null);
                self.doDisplayState();
                return true;
            }

            var vals	= {},
                valid	= true,
                val		= null,
                msg,
                i;

            if (cfg.value) {

                for (i in fields) {
                    vals[i]	= fields[i].getValue();
                }

                val	= cfg.value.call(self.$$callbackContext, vals, self);
            }

            for (i in rules) {

                var fn = isFunction(rules[i]) ? rules[i] : methods[i];

                if ((msg = fn.call(self.$$callbackContext, val, null, rules[i], self, vals)) !== true) {

                    valid = false;

                    if (msg || cfg.messages[i]) {
                        self.setError(format(msg || cfg.messages[i] || "", rules[i]));
                    }
                    else {
                        self.setError(null);
                    }

                    break;
                }

            }

            if (valid) {
                self.setError(null);
            }

            self.setValidState(valid);
            self.doDisplayState();

            return self.valid === true;
        },

        doDisplayState:			function() {

            var self    = this,
                valid	= self.valid,
                cfg     = self.cfg;

            if (!self.displayState && !cfg.alwaysDisplayState) {
                valid	= null;
            }

            if (cfg.errorBox) {

                var ebox = self.getErrorBox();

                if (valid !== null) {

                    if (ebox) {
                        ebox.innerHTML = self.error || '';
                        ebox.style.display = self.valid === false ? 'block' : 'none';
                    }
                }
                else {
                    if (ebox) {
                        ebox.style.display = "none";
                    }
                }
            }

            var errorCls	= cfg.cls.error,
                validCls	= cfg.cls.valid;

            valid = self.valid;

            if (errorCls) {
                valid === false ? addClass(self.el, errorCls) : removeClass(self.el, errorCls);
            }
            if (validCls) {
                valid === true ? addClass(self.el, validCls) : removeClass(self.el, validCls);
            }

            self.trigger('display-state', self, self.valid);
        },

        /**
         * @returns {Element}
         */
        getErrorBox: function() {

            var self    = this,
                cfg     = self.cfg,
                fields  = self.fields,
                eb	    = cfg.errorBox;

            if (fields[eb]) {
                return fields[eb].getErrorBox();
            }
            else if (!self.errorBox) {

                if (isFunction(cfg.errorBox)) {
                    self.errorBox	= cfg.errorBox.call(self.$$callbackContext, self);
                }
                else {
                    self.errorBox	= cfg.errorBox;
                }
            }

            return self.errorBox;
        },


        /**
         * Destroy group
         */
        onDestroy:	function() {

            var self    = this,
                fields  = self.fields;

            for (var i in fields) {
                if (fields[i]) {
                    self.setFieldEvents(fields[i], 'un');
                }
            }

            if (self.errorBox) {
                self.errorBox.parentNode.removeChild(self.errorBox);
            }
        },

        add:		function(field) {

            var self    = this,
                fields  = self.fields,
                id	    = field.getName();

            if (!fields[id]) {
                fields[id] 	= field;

                self.setFieldEvents(field, 'on');
            }
        },

        setFieldEvents:		function(f, mode) {
            var self = this;
            f[mode]('state-change', self.onFieldStateChange, self);
        },

        remove:		function(field) {

            var self    = this,
                fields  = self.fields,
                id	    = field.getName();

            if (fields[id]) {
                delete fields[id];
                self.setFieldEvents(field, 'un');
            }

            return self;
        },

        setValidState:			function(valid) {
            var self = this;
            if (self.valid !== valid) {
                self.valid = valid;
                self.trigger('state-change', self, valid);
            }
        },

        countInvalid:			function() {

            var self = this,
                fields = self.fields;

            self.invalid	= 0;
            for (var i in fields) {
                self.invalid += fields[i].isValid() ? 0 : 1;
            }
        },

        onFieldStateChange:		function(f, valid) {
            var self = this;
            self.trigger("field-state-change", self, f, valid);
            self.check();
        }
    }, {

        defaults: {}
    });

}());